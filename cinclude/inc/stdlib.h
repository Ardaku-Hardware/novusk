#ifndef _STDLIB_H
#define _STDLIB_H

// Warning: This file was autogenerated with cbindgen.
// To add bindings, edit the source and rerun cbindgen.

#include "stdint.h"
#include "stddef.h"

#define RAND_MAX 2147483647

#define EXIT_FAILURE 1

#define EXIT_SUCCESS 0

/**
 * Maximum length of a multibyte character in the current locale.
 */
#define MB_CUR_MAX 3

/**
 * Reentrant versions of the `random' family of functions. These functions all use the following
 * data structure to contain state, rather than global state variables.
 */
struct random_data {
  int32_t *front_ptr;
  int32_t *back_ptr;
  int32_t *state;
  int rand_type;
  int rand_deg;
  int rand_sep;
  int32_t *end_ptr;
};

struct div_t {
  int quot;
  int rem;
};

struct ldiv_t {
  long quot;
  long rem;
};

struct lldiv_t {
  long long quot;
  long long rem;
};

extern const unsigned char conv_table_l64a[64];

extern const unsigned char conv_table_a64l[77];

/**
 * Convert a string to a floating-point number.
 */
double atof(const char *s);

/**
 * Convert a string to an integer.
 */
int atoi(const char *s);

/**
 * Convert a string to a long integer.
 */
long atol(const char *s);

/**
 * Convert a string to a long long integer.
 */
long long atoll(const char *s);

/**
 * Convert a string to a floating-point number.
 */
double strtod(const char *n_ptr, const char *const *end_pointer);

/**
 * Convert a string to a float.
 */
float strtof(const char *s, char **endp);

/**
 * Convert a string to a long double.
 */
void strtold(const char *s, char **endp);

/**
 * Convert a string to a long integer.
 */
long strtol(const char *s, char **endp, int base);

/**
 * Convert a string to a quadword (long long) integer.
 */
long long strtoq(const char *s, char **endp, int base);

/**
 * Convert a string to an unsigned long integer.
 */
unsigned long strtoul(const char *s, char **endp, int base);

/**
 * Convert a string to an unsigned quadword (long long) integer.
 */
unsigned long long strtouq(const char *s, char **endp, int base);

/**
 * Convert a string to an quadword (long long) integer.
 */
long long strtoll(const char *s, char **endp, int base);

/**
 * Convert a string to an unsigned quadword (long long) integer.
 */
unsigned long long strtoull(const char *s, char **endp, int base);

/**
 * Convert a floating-point number to a string.
 */
char *strfromd(char *s, int buf_size, const char *format, double d);

/**
 * Convert a floating-point number to a string.
 */
char *strfromf(char *s, int buf_size, const char *format, float f);

/**
 * Convert a floating-point number to a string.
 */
char *strfroml(char *s, int buf_size, const char *format, long l);

/**
 * Convert n to base 64 using the digits "./0-9A-Za-z", least-significant digit first. Returns a
 * pointer to static storage overwritten by the next call.
 */
const unsigned char *l64a(long n);

/**
 * Read a number from a string s in base 64 as above.
 */
long a64l(const unsigned char *s);

/**
 * Return a random long integer in the range 0 to [`RAND_MAX`] inclusive.
 */
long random(void);

/**
 * Seed the random number generator with the given seed.
 */
void srandom(unsigned int seed);

/**
 * Initialize the random number generator to use state buffer STATEBUF, of length STATELEN, and
 * seed it with SEED.  Optimal lengths are 8, 16, 32, 64, 128 and 256, the bigger the better;
 * values less than 8 will cause an error and values greater than 256 will be rounded down.
 */
char *initstate(unsigned int seed,
                char *statebuf,
                int statelen);

/**
 * Switch the random number generator to state buffer STATEBUF, which should have been initialized
 * by [`initstate`].
 */
char *setstate(char *statebuf);

/**
 * Reentrant version of [`random`].
 */
int random_r(struct random_data *data, int *result);

/**
 * Reentrant version of [`srandom`].
 */
int srandom_r(unsigned int seed, struct random_data *data);

/**
 * Reentrant version of [`initstate`].
 */
int initstate_r(unsigned int seed,
                char *statebuf,
                int statelen,
                struct random_data *data);

/**
 * Reentrant version of [`setstate`].
 */
int setstate_r(char *statebuf, struct random_data *data);

/**
 * Return a random long integer in the range 0 to [`RAND_MAX`] inclusive.
 */
int rand(void);

/**
 * Seed the random number generator with the given seed.
 */
void srand(unsigned int seed);

/**
 * Reentrant version of [`rand`].
 */
int rand_r(const unsigned int *seed);

/**
 * Allocate size bytes of memory.
 */
void *malloc(size_t size);

/**
 * Allocate nmemb elements of size bytes each, all initialized to 0.
 */
void *calloc(size_t nmemb, size_t size);

/**
 * Re-allocate the previously allocated memory block pointed to by ptr, making the new memory block
 * size bytes long.
 */
void *realloc(void *ptr,
              size_t size);

/**
 * Re-allocate the previously allocated memory block pointed to by ptr, making the new memory block
 * large enough for nmemb elements of size bytes each.
 */
void *reallocarray(void *ptr,
                   size_t nmemb,
                   size_t size);

/**
 * Free a memory block previously allocated by [`malloc`], [`calloc`], or [`realloc`].
 */
void free(void *ptr);

/**
 * Allocate size bytes on a page boundary. The storage cannot be freed with [`free`].
 */
void *valloc(size_t size);

/**
 * ISO C variant of aligned allocation
 */
void *aligned_alloc(size_t alignment, size_t size);

/**
 * Abort execution and generate a core dump.
 */
void abort(void);

/**
 * Call all functions registered with [`atexit`] and [`on_exit`] in the reverse of the order in
 * which they were registered, perform any necessary cleanup, and terminate program execution with
 * status.
 */
void exit(int status);

/**
 * Call all functions registered with [`at_quick_exit`] in the reverse of the order in which they
 * were register, and terminate program execution with status.
 */
void quick_exit(int status);

/**
 * Terminate program execution immediately, without calling any of the registered exit functions.
 */
void _Exit(int status);

/**
 * Return the value of the environment variable name, or NULL if the variable is not defined.
 *
 * # Safety
 * `from_ptr` is unsafe because it is undefined behavior to pass a null pointer.
 */
char *getenv(const char *name);

/**
 * The [`clearenv`] function was planned to be added to POSIX.1 but probably never made it into
 * the standard. Nevertheless, the POSIX.9 standard (POSIX bindings for Fortran 77) requires it.
 */
void clearenv(void);

/**
 * Return a [`malloc`]'d string containing the canonical name of the supplied path.
 */
char *canonicalize_file_name(const char *name);

/**
 * Return the absolute value of int x.
 */
int abs(int x);

/**
 * Return the absolute value of long int x.
 */
long labs(long x);

/**
 * Return the absolute value of long long int x.
 */
long long llabs(long long x);

/**
 * Return the [`div_t`] representation of integer division of numer/denom.
 */
struct div_t div(int numer, int denom);

/**
 * Return the [`ldiv_t`] representation of long integer division of numer/denom.
 */
struct ldiv_t ldiv(long numer, long denom);

/**
 * Return the [`lldiv_t`] representation of long long integer division of numer/denom.
 */
struct lldiv_t lldiv(long long numer,
                     long long denom);

/**
 * Test if the Rust-ffi interface is working.
 */
int rust_ffi_test(void);

/**
 * Use the types required for CBindgen
 */
void _use_div_types(void);

#endif /* _STDLIB_H */
